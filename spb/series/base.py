import math
import numpy as np
import param
from numbers import Number
from inspect import signature
from spb.wegert import wegert
from spb.defaults import cfg
from spb.utils import (
    _get_free_symbols, unwrap, extract_solution, tf_to_control
)
import sympy
from sympy import (
    latex, Tuple, arity, symbols, sympify, solve, Expr, lambdify,
    Equality, Ne, GreaterThan, LessThan, StrictLessThan, StrictGreaterThan,
    Plane, Polygon, Circle, Ellipse, Segment, Ray, Curve, Point2D, Point3D,
    atan2, floor, ceiling, Sum, Product, Symbol, frac, im, re, zeta, Poly,
    Union, Interval, nsimplify, Set, Integral, hyper, fraction
)
from sympy.core.relational import Relational
from sympy.calculus.util import continuous_domain
from sympy.geometry.entity import GeometryEntity
from sympy.geometry.line import LinearEntity2D, LinearEntity3D
from sympy.logic.boolalg import BooleanFunction
from sympy.plotting.intervalmath import interval
from sympy.external import import_module
from sympy.printing.pycode import PythonCodePrinter
from sympy.printing.precedence import precedence
from sympy.core.sorting import default_sort_key
from matplotlib.cbook import (
    pts_to_prestep, pts_to_poststep, pts_to_midstep
)
import warnings
from spb.series.evaluator import GridEvaluator
from param.ipython import ParamPager


# # ANSI color codes for the IPython pager
# red   = '\x1b[1;31m%s\x1b[0m'
# blue  = '\x1b[1;34m%s\x1b[0m'
# green = '\x1b[1;32m%s\x1b[0m'
# cyan = '\x1b[1;36m%s\x1b[0m'


# class MyParamPager(ParamPager):
#     def __call__(self, param_obj):
#         """
#         Given a Parameterized object or class, display information
#         about the parameters in the IPython pager.
#         """
#         print("MyParamPager.__call__")
#         # return "shit"

#         title = None
#         if not self.metaclass:
#             print("a")
#             parameterized_object = isinstance(param_obj, param.Parameterized)
#             parameterized_class = (isinstance(param_obj,type)
#                                    and  issubclass(param_obj,param.Parameterized))

#             if not (parameterized_object or parameterized_class):
#                 print("a 1")
#                 print("Object is not a Parameterized class or object.")
#                 return

#             if parameterized_object:
#                 print("a 2")
#                 # Only show the name if not autogenerated
#                 class_name = param_obj.__class__.__name__
#                 default_name = re.match('^'+class_name+'[0-9]+$', param_obj.name)
#                 obj_name = '' if default_name else (' %r' % param_obj.name)
#                 title = f'Parameters of {class_name!r} instance{obj_name}'

#         if title is None:
#             title = 'Parameters of %r' % param_obj.name

#         heading_line = '=' * len(title)
#         heading_text = f"{title}\n{heading_line}\n"

#         param_info = self.get_param_info(param_obj, include_super=True)
#         if not param_info[0]:
#             print("b")
#             top_heading = green % heading_text
#             return f"{top_heading}\nObject has no parameters."

#         table = self._build_table(param_info, self.order, max_col_len=40,
#                                   only_changed=False)

#         docstrings = self.param_docstrings(param_info, max_col_len=100, only_changed=False)
#         dflt_msg = "Parameters changed from their default values are marked in red."
#         # top_heading = (green % heading_text)
#         # top_heading += "\n%s" % (red % dflt_msg)
#         # top_heading += "\n%s" % (cyan % "Soft bound values are marked in cyan.")
#         # top_heading += '\nC/V= Constant/Variable, RO/RW = ReadOnly/ReadWrite, AN=Allow None'

#         heading_text = 'Parameter docstrings:'
#         heading_string = f"{heading_text}\n{'=' * len(heading_text)}"
#         docstring_heading = (green % heading_string)
#         print("c")
#         return f"YEAH\n\n{docstring_heading}\n\n"


# param_pager = MyParamPager(metaclass=True)


def _get_wrapper_for_expr(ret):
    wrapper = "%s"
    if ret == "real":
        wrapper = "re(%s)"
    elif ret == "imag":
        wrapper = "im(%s)"
    elif ret == "abs":
        wrapper = "abs(%s)"
    elif ret == "arg":
        wrapper = "arg(%s)"
    return wrapper


def _raise_color_func_error(series, nargs):
    if not isinstance(series, BaseSeries):
        return
    if series.color_func is None:
        return

    class_ = type(series).__name__

    raise ValueError(
        "Error while processing the `color_func` of this series:\n"
        f"Wrong number of arguments ({nargs}) of {class_}'s `color_func`."
        " Here is the documentation of the `color_func` attribute:\n\n"
        f"{series.param.color_func.doc}"
    )

class _ParametersDict(param.Dict):
    """As of `param 2.2.0, there is no mechanism to preprocess the value
    of an attribute just before it is set. This class allows to do just that.

    https://discourse.holoviz.org/t/what-is-the-best-way-to-make-custom-validation-and-transform-before-validation/3369
    """

    def __set__(self, obj, val):
        """Preprocess the parameters provided to the series.

        NOTE: at this point, if the data series is being instantiated,
        val is a dictionary with the following form:
            {
                symb1: (1, 0, 10, "label"),
                symb2: FloatSlider(value=2, min=0, max=5),
                (symb3, symb4): RangeSlider(...),
            }
        On the other hand, if the data series is being updated with new
        data from the widgets, val has this form:
            {
                symb1: val1,
                symb2: val2,
                (symb3, symb4): (val3, val4),
            }

        Here I unpack (symb3, symb4) so that self.param.keys()
        contains only symbols. This is what val is going to look
        after the preprocessing:
            {
                symb1: (1, 0, 10, "label"),
                symb2: FloatSlider(value=2, min=0, max=5),
                symb3: RangeSlider(...),
                symb4: RangeSlider(...),
            }
        Or if numeric values are provided:
            {
                symb1: val1,
                symb2: val2,
                symb3: val3,
                symb4: val4,
            }
        """
        # NOTE: Data series are unable to extract numerical values
        # from widgets. This step is done by iplot(). Before executing
        # the get_data() method, be sure to provide a ``params``
        # dictionary mapping symbols to numeric values.

        if any(isinstance(t, (list, tuple)) for t in val.keys()):
            new_params = {}
            for k, v in val.items():
                if isinstance(k, (list, tuple)):
                    # we are dealing with a multivalued widget
                    if isinstance(v, (list, tuple)):
                        # this is executed when params is updated with new
                        # numerical data from the widget
                        for symb, num in zip(k, v):
                            new_params[symb] = num
                    else:
                        # this is executed at data series instantiation
                        for symb in k:
                            new_params[symb] = v
                else:
                    new_params[k] = v
            val = new_params

        super().__set__( obj, val)

class _TzParameter(param.Parameterized):
    tz = param.Callable(doc="""
        Numerical transformation function to be applied to the data on the
        z-axis, if the data series is used in 3D plots.""")


class _TpParameter(param.Parameterized):
    tp = param.Callable(doc="""
        Numerical transformation function to be applied to the data on the
        parameter, if the data series is used in parametric plots (the one
        using colormaps).""")

class BaseSeries(param.Parameterized):
    """Base class for the data objects containing stuff to be plotted.

    Notes
    =====

    The backend should check if it supports the data series that it's given.
    It's the backend responsibility to know how to use the data series that
    it's given.
    """

    # Some flags follow. The rationale for using flags instead of checking
    # base classes is that setting multiple flags is simpler than multiple
    # inheritance.

    is_2Dline = False

    is_3Dline = False

    is_3Dsurface = False

    is_contour = False

    is_implicit = False
    # Both contour and implicit series uses colormap, but they are different.
    # Hence, a different attribute

    is_parametric = False

    is_vector = False
    is_2Dvector = False
    is_3Dvector = False
    is_slice = False
    # Represents a 2D or 3D vector

    is_complex = False
    # Represent a complex expression
    is_domain_coloring = False

    is_geometry = False
    # If True, it represents an object of the sympy.geometry module

    is_generic = False
    # Implement back-compatibility with sympy.plotting <= 1.11
    # Please, read NOTE section on GenericDataSeries

    is_grid = False
    # Represents grids like s-grid, z-grid, n-grid, ...

    _allowed_keys = []
    # contains a list of keyword arguments supported by the series. It will be
    # used to validate the user-provided keyword arguments.

    _N = 100
    # default number of discretization points for uniform sampling. Each
    # subclass can set its number.

    #####################
    # Instance Attributes
    #####################


    # NOTE: some data series should not be shown on the legend, for example
    # wireframe lines on 3D plots.
    show_in_legend = param.Boolean(True, doc="""
        Toggle the visibility of the data series on the legend.""")
    colorbar = param.Boolean(True, doc="""
        Toggle the visibility of the colorbar associated to the current data
        series. Note that a colorbar is only visible if ``use_cm=True`` and
        ``color_func`` is not None.""")
    use_cm = param.Boolean(False, doc="""
        Toggle the use of a colormap. By default, some series might use a
        colormap to display the necessary data. Setting this attribute
        to False will inform the associated renderer to use solid color.""")
    # TODO: can I remove _label_str and only keep label?
    label = param.String("", doc="""
        Get or set the label associated to this series, which will be
        eventually shown on the legend or colorbar. By default the data series
        stores two labels: one for the string representation of the symbolic
        expression, the other for the latex representation. The plotting
        library will then decide which one is best to be shown. If the user
        set this parameter, both labels will receive the same value.
        To retrieve one or the other representation, call the ``get_label``
        method of the data series.""")
    rendering_kw = param.Dict(doc="""
        Keyword arguments to be passed to the renderers of the selected
        plotting library in order to further customize the appearance of this
        data series.""")
    # TODO: can the code be modified so that series.params ALWAYS returns
    # a dictionary mapping symbols to numerical values? This requires
    # the extraction of values during series instantiation.
    params = _ParametersDict({}, doc="""
        A dictionary mapping symbols to parameters. If provided, this
        dictionary enables the interactive-widgets plot, which doesn't support
        the adaptive algorithm (meaning it will use ``adaptive=False``).

        When calling a plotting function, the parameter can be specified with:

        * a widget from the ``ipywidgets`` module.
        * a widget from the ``panel`` module.
        * a tuple of the form:
           `(default, min, max, N, tick_format, label, spacing)`,
           which will instantiate a
           :py:class:`ipywidgets.widgets.widget_float.FloatSlider` or
           a :py:class:`ipywidgets.widgets.widget_float.FloatLogSlider`,
           depending on the spacing strategy. In particular:

           - default, min, max : float
                Default value, minimum value and maximum value of the slider,
                respectively. Must be finite numbers. The order of these 3
                numbers is not important: the module will figure it out
                which is what.
           - N : int, optional
                Number of steps of the slider.
           - tick_format : str or None, optional
                Provide a formatter for the tick value of the slider.
                Default to ``".2f"``.
           - label: str, optional
                Custom text associated to the slider.
           - spacing : str, optional
                Specify the discretization spacing. Default to ``"linear"``,
                can be changed to ``"log"``.

        Notes:

        1. parameters cannot be linked together (ie, one parameter
           cannot depend on another one).
        2. If a widget returns multiple numerical values (like
           :py:class:`panel.widgets.slider.RangeSlider` or
           :py:class:`ipywidgets.widgets.widget_float.FloatRangeSlider`),
           then a corresponding number of symbols must be provided.

        Here follows a couple of examples. If ``imodule="panel"``:

        .. code-block:: python

            import panel as pn
            params = {
                a: (1, 0, 5), # slider from 0 to 5, with default value of 1
                b: pn.widgets.FloatSlider(value=1, start=0, end=5), # same slider as above
                (c, d): pn.widgets.RangeSlider(value=(-1, 1), start=-3, end=3, step=0.1)
            }

        Or with ``imodule="ipywidgets"``:

        .. code-block:: python

            import ipywidgets as w
            params = {
                a: (1, 0, 5), # slider from 0 to 5, with default value of 1
                b: w.FloatSlider(value=1, min=0, max=5), # same slider as above
                (c, d): w.FloatRangeSlider(value=(-1, 1), min=-3, max=3, step=0.1)
            }

        When instantiating a data series directly, ``params`` must be a
        dictionary mapping symbols to numerical values.

        Let ``series`` be any data series. Then ``series.params`` returns a
        dictionary mapping symbols to numerical values.
        """)
    tx = param.Callable(doc="""
        Numerical transformation function to be applied to the data on the
        x-axis.""")
    ty = param.Callable(doc="""
        Numerical transformation function to be applied to the data on the
        y-axis.""")
    # TODO: xscale or x_scale?
    xscale = param.Selector(
        default="linear", objects=["linear", "log"], doc="""
        Discretization strategy along the x-direction.""")
    yscale = param.Selector(
        default="linear", objects=["linear", "log"], doc="""
        Discretization strategy along the y-direction.""")
    zscale = param.Selector(
        default="linear", objects=["linear", "log"], doc="""
        Discretization strategy along the z-direction.""")
    # NOTE: item_type=Number allows users to set float numbers, like 1e04.
    # Then, once the parameter has been set and validated, it triggers the
    # _cast_to_int function, which converts all ements to int.
    n = param.List([100, 100, 100], item_type=Number, bounds=(3, 3), doc="""
        Number of discretization points along the x, y, z directions,
        respectively. It can easily be set with ``n=number``, which will
        set ``number`` for each element of the list.
        For surface, contour, 2d vector field plots it can be set with
        ``n=[num1, num2]``. For 3D implicit plots it can be set with
        ``n=[num1, num2, num3]``.

        Alternatively, ``n1=num1, n2=num2, n3=num3`` can be indipendently
        set in order to modify the respective element of the ``n`` list.""")
    # TODO: better doc for all data series
    color_func = param.Parameter(default=None, doc="""
        A color function to be applied to the numerical data. It can be:

        * None: no color function.
        * callable: a function returning numerical data.
        * Expr: A symbolic expression having at most as many free symbols as
          ``expr``.
        """)

    _label_str = param.String("", doc="""Contains str representation.""")
    _label_latex = param.String("", doc="""Contains latex representation.""")
    _is_interactive = param.Boolean(False, constant=True, doc="""
        Verify if this data series is interactive or not. Each data series
        expect one (or more) symbols to be specified as a discretization
        variable (ie, the ranges of the data series). However, the symbolic
        expressions may contain more symbols than what is expected by the
        ranges. In that case, the additional symbols are considered parameters,
        which will receive numerical values from interactive widgets.
        If this parameter is True, then the ``params`` attributes contains
        a non-empty dictionary.""")
    # TODO: I probably don't need this if I can better implement ``params``
    # in the first place. See TODO on ``params``.
    _original_params = param.Dict({}, doc="""
        This stores a copy of the ``params`` dictionary, just as it was
        provided by the user during a plotting function call. It is used
        by spb.interactive to keep track of multi-values widgets, which
        allows the mapping of symbols to the appropriate numerical values.""")
    _parametric_ranges = param.Boolean(False, doc="""
        Whether the series contains any parametric range, which is a range
        depending on symbols contained in ``params.keys()``.""")
    evaluator = param.ClassSelector(class_=GridEvaluator, doc="""
        The machinery that generates numerical data starting from
        the parameters of the current series.""")
    expr = param.Parameter(doc="""
        This parameter is meant to be read-only. Depending on the type of the
        data series, it returns one or more symbolic expressions (or numerical
        functions). This parameter is used by the evaluator in order to
        retrieve the expressions to be lambdified and evaluated.""")
    # ranges = param.List(default=[], doc="""
    #     Return a list of 3-elements tuples, each one having the form
    #     (symbol, min, max), representing the ranges of numerical values
    #     used by each of the specified symbols.""")
    # _exclude_params_from_doc = param.List(default=[], item_type=str, doc="""
    #     List of parameter names to be excluded from the documentation, either
    #     because they are meant to remain private, or because they are
    #     inherithed from a base class and are unused on the current class.""")

    # def __class_docstring(mcs):
    #     """
    #     Customize the class docstring with a Parameter table if
    #     `docstring_describe_params` and the `param_pager` is available.
    #     """
    #     if not param_pager:
    #         return
    #     print("__class_docstring")
    #     # class_docstr = mcs.__doc__ if mcs.__doc__ else ''
    #     description = param_pager(mcs)
    #     # mcs.__doc__ = class_docstr + '\n' + description
    #     # print(description)
    #     # print("DESCRIPTION IS OVER")
    #     mcs.__doc__ = "no shit"

    def __repr__(self):
        if cfg["use_repr"] is False:
            return object.__repr__(self)
        return super().__repr__()

    # def _repr_html()

    @param.depends("expr", watch=True)
    def _update_evaluator(self):
        if self.evaluator is not None:
            self.evaluator.set_expressions()

    @param.depends("n", watch=True, on_init=True)
    def _cast_to_int(self):
        """Convert the number of discretization points to integer.
        This allows the user to specify float numbers, like ``n=1e04``.
        """
        self.n = [int(t) for t in self.n]

    # # TODO: do I need this?
    # @param.depends("rendering_kw", watch=True, on_init=True)
    # def _enforce_dict_on_rendering_kw(self):
    #     if self.rendering_kw is None:
    #         self.rendering_kw = {}

    def _enforce_dict_on_rendering_kw(self, rendering_kw):
        return {} if rendering_kw is None else rendering_kw

    @param.depends("_label_str", watch=True)
    def _update_label(self):
        # NOTE: this implements back-compatibility with sympy.plotting
        self.label = self._label_str

    @param.depends("label", watch=True)
    def _update_latex_and_str_labels(self):
        # this is triggered when someone changes the label after instantiating
        # the plot, like p[0].label = "something"
        self._label_latex = self.label
        self._label_str = self.label

    _allowed_keys = [
        "show_in_legend", "colorbar", "use_cm", "scatter", "label",
        "n1", "n2", "n3", "xscale", "yscale", "zscale", "params",
        "rendering_kw", "tx", "ty", "tz", "tp", "color_func"
    ]

    def __init__(self, *args, **kwargs):
        # allow the user to specify the number of discretization points
        # using different keyword arguments
        kwargs = _set_discretization_points(kwargs.copy(), type(self))

        # user (or plotting function) may still provide None to rendering_kw.
        # here we prevent this event from raising errors.
        # This helps to maintain back-compatibility with the graphics module.
        rendering_kw = kwargs.get("rendering_kw", None)
        if rendering_kw is None:
            kwargs["rendering_kw"] = {}

        # if user provides a label, overrides both the string and latex
        # representations
        label = kwargs.get("label", None)
        if label:
            kwargs["_label_str"] = kwargs["_label_latex"] = label

        _params = kwargs.setdefault("params", {})
        # this is used by spb.interactive to keep track of multi-values widgets
        kwargs.setdefault("_original_params", kwargs.get("params", {}))

        # remove keyword arguments that are not parameters of this series
        kwargs = {
            k: v for k, v in kwargs.items()
            if k in self._get_list_of_allowed_params()
        }

        super().__init__(*args, **kwargs)

        self._ranges = []

        if len(_params) > 0:
            with param.edit_constant(self):
                self._is_interactive = True

        # if docstring_signature:
        # self.__class_docstring()

    def _post_init(self):
        exprs = self.expr if hasattr(self.expr, "__iter__") else [self.expr]
        if any(callable(e) for e in exprs) and self.params:
            raise TypeError(
                "`params` was provided, hence an interactive plot "
                "is expected. However, interactive plots do not support "
                "user-provided numerical functions.")

        # if the expressions is a lambda function and no label has been
        # provided, then its better to do the following in order to avoid
        # suprises on the backend
        if any(callable(e) for e in exprs):
            if self._label_str == str(self.expr):
                self.label = ""

        self._check_fs()

        # if hasattr(self, "adaptive") and self.adaptive and self.params:
        #     warnings.warn(
        #         "`params` was provided, hence an interactive plot "
        #         "is expected. However, interactive plots do not support "
        #         "adaptive evaluation. Automatically switched to "
        #         "adaptive=False.")
        #     self.adaptive = False

    @classmethod
    def _get_list_of_allowed_params(cls):
        # also allows n1, n2, n3. they will be removed later on inside
        # _set_discretization_points
        return list(cls.param) + [
            "n1", "n2", "n3", "nb_of_points",
            "nb_of_points_x", "nb_of_points_y",
            "nb_of_points_u", "nb_of_points_v"
        ]

    def _block_lambda_functions(self, *exprs):
        if any(callable(e) for e in exprs):
            raise TypeError(type(self).__name__ + " requires a symbolic "
                "expression.")

    def _check_fs(self):
        """ Checks if there are enogh parameters and free symbols.
        """
        exprs, ranges = self.expr, self.ranges
        params, label = self.params, self.label
        exprs = exprs if hasattr(exprs, "__iter__") else [exprs]
        if any(callable(e) for e in exprs):
            return

        # from the expression's free symbols, remove the ones used in
        # the parameters and the ranges
        fs = _get_free_symbols(exprs)
        fs = fs.difference(params.keys())
        if ranges is not None:
            fs = fs.difference([r[0] for r in ranges])

        if len(fs) > 0:
            if (ranges is not None) and len(ranges) > 0:
                erl = "Expression: %s\nRanges: %s\nLabel: %s\n" % (
                    exprs, ranges, label)
            else:
                erl = "Expression: %s\nLabel: %s\n" % (exprs, label)
            raise ValueError(
                "Incompatible expression and parameters.\n%s"
                "params: %s\n"
                "Specify what these symbols represent: %s\n"
                "Are they ranges or parameters?" % (erl, params, fs)
            )

        # verify that all symbols are known (they either represent plotting
        # ranges or parameters)
        range_symbols = [r[0] for r in ranges]
        for r in ranges:
            fs = set().union(*[e.free_symbols for e in r[1:]])
            if any(t in fs for t in range_symbols):
                raise ValueError("Range symbols can't be included into "
                    "minimum and maximum of a range. "
                    "Received range: %s" % str(r))
            remaining_fs = fs.difference(params.keys())
            if len(remaining_fs) > 0:
                raise ValueError(
                    "Unkown symbols found in plotting range: %s. " % (r,) +
                    "Are the following parameters? %s" % remaining_fs)

    # def _update_range_value(self, t):
    #     """Given a symbolic expression, `t`, substitutes the parameters if
    #     this series is interactive.
    #     """
    #     if not self._parametric_ranges:
    #         return complex(t)
    #     return complex(t.subs(self.params))

    # @property
    # def expr(self):
    #     """Return the expression (or expressions) of the series."""
    #     return self._expr

    # @expr.setter
    # def expr(self, v):
    #     self._expr = v

    @property
    def is_3D(self):
        flags3D = [self.is_3Dline, self.is_3Dsurface, self.is_3Dvector]
        return any(flags3D)

    @property
    def is_line(self):
        flagslines = [self.is_2Dline, self.is_3Dline]
        return any(flagslines)

    @property
    def is_interactive(self):
        return self._is_interactive

    # @is_interactive.setter
    # def is_interactive(self, value):
    #     self._is_interactive = value

    def _line_surface_color(self, prop, val):
        """This method enables back-compatibility with old sympy.plotting"""
        # NOTE: color_func is set inside the init method of the series.
        # If line_color/surface_color is not a callable, then color_func will
        # be set to None.
        prop = prop[1:] # remove underscore
        if callable(val) or isinstance(val, Expr):
            prop_val = None
            cf_val = val
        else:
            prop_val = val
            cf_val = None

        # prevents the triggering of events, which would cause recursion error
        with param.discard_events(self):
            setattr(self, prop, prop_val)
            if val is not None:
                # avoid resetting color_func when user writes line_color=None
                self.color_func = cf_val

    @property
    def scales(self):
        return [self.xscale, self.yscale, self.zscale]

    def eval_color_func(self, *args):
        """
        Evaluate the color function. Depending on the data series, either the
        data series itself or the backend will eventually execute this function
        to generate the appropriate coloring value.

        Parameters
        ==========

        args : tuple
            Arguments to be passed to the coloring function. Can be coordinates
            or parameters or both. Read the documentation of each data series
            `color_func` attribute to find out what the arguments should be.
        """
        raise NotImplementedError

    def get_data(self):
        """Compute and returns the numerical data.

        The number of arrays returned by this method depends on the
        specific instance. Let ``s`` be an instance of ``BaseSeries``.
        Make sure to read ``help(s.get_data)`` to understand what it returns.
        """
        raise NotImplementedError

    def _get_wrapped_label(self, label, wrapper):
        """Given a latex representation of an expression, wrap it inside
        some characters. Matplotlib needs "$%s%$", K3D-Jupyter needs "%s".
        """
        return wrapper % label

    def get_label(self, use_latex=False, wrapper="$%s$"):
        """
        Return the label to be used to display the expression.

        Parameters
        ==========
        use_latex : bool
            If False, the string representation of the expression is returned.
            If True, the latex representation is returned.
        wrapper : str
            The backend might need the latex representation to be wrapped by
            some characters. Default to ``"$%s$"``.

        Returns
        =======
        label : str
        """
        if use_latex is False:
            return self._label_str
        if self._label_str == str(self.expr):
            return self._get_wrapped_label(self._label_latex, wrapper)
        return self._label_latex

    # @param.depends("ranges", watch=True)
    @property
    def ranges(self):
        """
        Return a list of 3-elements tuples, each one having the form
        (symbol, min, max), representing the ranges of numerical values
        used by each of the specified symbols.
        """
        return self._ranges

    @ranges.setter
    def ranges(self, values):
        new_vals = []
        for v in values:
            if v is not None:
                new_vals.append(tuple(map(sympify, v)))

        numbers_or_expressions = set().union(*[nv[1:] for nv in new_vals])
        fs = set().union(*[e.free_symbols for e in numbers_or_expressions])
        if len(fs) > 0:
            self._parametric_ranges = True
        self._ranges = new_vals

    def _apply_transform(self, *args):
        """Apply transformations to the results of numerical evaluation.

        Parameters
        ==========
        args : tuple
            Results of the numerical evaluation.

        Returns
        =======
        transformed_args : tuple
            Tuple containing the transformed results.
        """
        raise NotImplementedError

    def _get_transform_helper(self):
        t = lambda x, transform: x if transform is None else transform(x)
        return t

    def _str_helper(self, s):
        pre, post = "", ""
        if self.is_interactive:
            pre = "interactive "
            post = " and parameters " + str(tuple(self.params.keys()))
        return pre + s + post


def _set_discretization_points(kwargs, Series):
    """Allow the use of the keyword arguments n, n1 and n2 (and n3) to
    specify the number of discretization points in two (or three) directions.

    Parameters
    ==========

    kwargs : dict

    Series : BaseSeries
        The type of the series, which indicates the kind of plot we are
        trying to create.

    Returns
    =======

    kwargs : dict
    """

    number_kw = ["n1", "n2", "n3"]
    deprecated_keywords = {
        "nb_of_points": "n",
        "nb_of_points_x": number_kw[0],
        "nb_of_points_y": number_kw[1],
        "nb_of_points_u": number_kw[0],
        "nb_of_points_v": number_kw[1],
        "points": "n"
    }
    for k, v in deprecated_keywords.items():
        if k in kwargs.keys():
            kwargs[v] = kwargs.pop(k)

    n = [Series._N] * 3
    provided_n = kwargs.get("n", None)
    if provided_n is not None:
        if hasattr(provided_n, "__iter__"):
            for i in range(min(len(provided_n), 3)):
                n[i] = provided_n[i]
        else:
            n = [provided_n] * 3

    kwargs["n"] = [kwargs.pop(k, n[i]) for i, k in enumerate(number_kw)]

    return kwargs
