"""
This module exposes a few decorators that will modify the hardcoded
docstrings of functions and classes.

Why this approach?

 * `param` automatically generates documentation for instances of
   `param.Parameterized`, but I don't really like its styling.
   In particular:

   * It shows a summary table of all parameters, showing their default
     values, wheter they are read and write, etc. For classes with many
     parameters, the table becomes long, it doesn't look good and it
     definitely doesn't convey all the important information, like
     available options for selectors, etc.
   * It shows headers like 'Parameters of <ClassName>'. While this looks
     good on IPython, it will not be rendered by Sphinx when using
     `numpydoc`. So, I need a way to replace this header with something
     recognizable by `numpydoc`, like 'Parameters'.
   * By default, parameters are sorted according to their precedence in the
     __mro__ of the class. I need them to be shown alphabetically,
     but first showing the parameters appearing in the __init__ signature.
   * Parameters' docstring do not entirely convey the necessary information.
     Think for example to `param.Selector`: it won't show the available
     options.

   So, to solve all these problem I had to create a custom ParamPager.

* Regarding the functions from `spb.graphics` or `spb.plot_functions`: each
  function instantiates a particular data series. Hardcoding the documentation
  of all parameters is tedius, error-prone and most importantly, very
  difficult to keep it updated if/when a parameter will change value,
  or will be removed. Thanks to these decorators, each function will
  automatically shows parameters from the data series it is going to
  instantiate.
"""

import inspect
import param
from param.ipython import ParamPager
import re
import textwrap

try:
    get_ipython()
    is_ipython = True
except:
    is_ipython = False

# ANSI color codes for the IPython pager
red   = '\x1b[1;31m%s\x1b[0m' if is_ipython else '%s'
blue  = '\x1b[1;34m%s\x1b[0m' if is_ipython else '%s'
green = '\x1b[1;32m%s\x1b[0m' if is_ipython else '%s'
cyan = '\x1b[1;36m%s\x1b[0m' if is_ipython else '%s'
colors = [red, blue, green, cyan]
WARN_MISFORMATTED_DOCSTRINGS = False

# while parsing the hard-coded docstring, this pattern will match lines like:
# a : int
# b :
# c : bool, dict
# d, e : float
#
# But not lines like:
# :py:class:`panel.widgets.slider.RangeSlider`
param_pattern = re.compile(r'^\s*([a-zA-Z_]\w*(?:\s*,\s*[a-zA-Z_]\w*)*)\s*:\s*([\w\s,]*)$')

# NOTE: these are the numpydoc sections that I'm aware of. They will be used
# as keys in some dictionary. 'general' is not a real section: the value
# associated to this key will be lines of docstring starting from line 0
# up to the first section which will be found.
# The final docstring will be build according to the order of these keys.
numpydoc_sections_to_look_for = [
    "general", "Parameters", "Attributes", "Methods",
    "Returns", "Yields", "Raises", "Warns", "Warnings",
    "Examples", "Notes", "References", "See Also",
]


_PARAM_TYPE_MAP = {
    param.String: "str",
    param.Boolean: "bool",
    param.Integer: "int",
    param.Number: "float",
    param.Tuple: "tuple",
    param.List: "list",
    param.Dict: "dict",
    param.Callable: "callable",
    param.Parameter: "",
}


def _validate_style(style: str):
    available_styles = ["param", "numpydoc"]
    if style not in available_styles:
        raise ValueError(
            f"`style` must be one of these options: {available_styles}."
            f" Instead, '{style}' was received."
        )


class MyParamPager(ParamPager):
    def __init__(self, metaclass=False, style="param"):
        super().__init__(metaclass)
        _validate_style(style)
        self.style = style

    def __call__(self, param_obj):
        """
        Given a Parameterized object or class, display information
        about the parameters in the IPython pager.
        """

        title = None
        if not self.metaclass:
            parameterized_object = isinstance(param_obj, param.Parameterized)
            parameterized_class = (isinstance(param_obj,type)
                                   and  issubclass(param_obj,param.Parameterized))

            if not (parameterized_object or parameterized_class):
                print("Object is not a Parameterized class or object.")
                return

            if parameterized_object:
                # Only show the name if not autogenerated
                class_name = param_obj.__class__.__name__
                default_name = re.match('^'+class_name+'[0-9]+$', param_obj.name)
                obj_name = '' if default_name else (' %r' % param_obj.name)
                title = f'Parameters of {class_name!r} instance{obj_name}'

        if title is None:
            title = 'Parameters of %r' % param_obj.name

        heading_line = '=' * len(title)
        heading_text = f"{title}\n{heading_line}\n"

        param_info = self.get_param_info(param_obj, include_super=True)
        if not param_info[0]:
            top_heading = green % heading_text
            return f"{top_heading}\nObject has no parameters."

        heading_text = 'Parameters'
        heading_string = f"{heading_text}\n{'=' * len(heading_text)}"
        docstring_heading = (green % heading_string)
        docstrings = self.param_docstrings(
            param_info, max_col_len=100, only_changed=False)
        return f"\n\n{docstring_heading}\n\n{docstrings}"

    def param_docstrings(self, info, max_col_len=100, only_changed=False):
        """
        Build a string to that presents all of the parameter
        docstrings in a clean format (alternating red and blue for
        readability).
        """

        (params, val_dict, changed) = info
        contents = []
        displayed_params = []

        for name in self.sort_by_precedence(params):
            if only_changed and not (name in changed):
                continue
            displayed_params.append((name, params[name]))

        parameters_dict = _get_parameters_dict(displayed_params)
        contents = _assemble_parameters_docstring(
            parameters_dict, self.style)
        return contents

    def get_param_info(self, obj, include_super=True):
        """
        Get the parameter dictionary, the list of modifed parameters
        and the dictionary of parameter values. If include_super is
        True, parameters are also collected from the super classes.
        """
        params, val_dict, changed = _get_param_info_helper(obj, include_super)
        return (params, val_dict, changed)


def _assemble_parameters_docstring(parameters: dict, style: str) -> str:
    right_shift = max(len(name) for name in parameters) + 2
    contents = []

    for i, name in enumerate(parameters):
        if style == "param":
            heading = f"{name}: "
        else:
            heading = f"{name} : {parameters[name]["type"]}"

        unindented = parameters[name]["doc"]

        lines = unindented.splitlines()
        if style == "param":
            if len(lines) > 1:
                tail = [f"{' '  * right_shift}{line}" for line in lines[1:]]
                all_lines = [heading.ljust(right_shift) + lines[0]] + tail
            elif len(lines) == 1:
                all_lines = [heading.ljust(right_shift) + lines[0]]
            else:
                all_lines = []
        else:
            all_lines = [heading] + [
                textwrap.indent(line, "    ") for line in lines]

        if i % 2:  # Alternate red and blue for docstrings
            contents.extend([red % el for el in all_lines])
        else:
            contents.extend([blue % el for el in all_lines])
    return "\n".join(contents)


def _get_parameters_from_object(obj) -> dict:
    """
    Returns
    =======
    A dictionary with the form {
        "param_name_1": parameter_1,
        "param_name_2": parameter_2,
    }
    where parameter_1, parameter_2 are parameters from the `param` module.
    """
    if (
        (not isinstance(obj, param.Parameterized))
        and (not issubclass(obj, param.Parameterized))
    ):
        return {}

    params = dict(obj.param.objects('existing'))
    # do not show 'private' parameters
    params = {k: v for k, v in params.items() if k[0] != "_"}
    if hasattr(obj, "_exclude_params_from_doc"):
        params = {
            k: v for k, v in params.items()
            if k not in obj._exclude_params_from_doc
        }
    return params


def _get_param_info_helper(obj, include_super=True):
    """
    Get the parameter dictionary, the list of modifed parameters
    and the dictionary of parameter values. If include_super is
    True, parameters are also collected from the super classes.
    """

    params = _get_parameters_from_object(obj)

    # get the class' __init__ method's or __call__ method's signature
    method = obj.__init__
    if issubclass(obj, param.ParameterizedFunction):
        method = obj.__call__
    init_signature = list(inspect.signature(method).parameters.keys())
    init_signature = [
        p for p in init_signature if p not in ["self", "kwargs"]]

    # sort parameters: first the ones shown in the signature, then
    # alphabetically sort the remaining
    params = _sort_parameters_by_signature(params, init_signature)

    if isinstance(obj, type):
        changed = []
        val_dict = {k: p.default for (k, p) in params.items()}
        self_class = obj
    else:
        changed = list(obj.param.values(onlychanged=True).keys())
        val_dict = obj.param.values()
        self_class = obj.__class__

    if not include_super:
        params = {k:v for (k,v) in params.items()
                    if k in self_class.__dict__}

    params.pop('name') # Already displayed in the title.
    return (params, val_dict, changed)


def _sort_parameters_by_signature(params: dict, signature: list) -> dict:
    """
    Given a dictionary of parameters where the keys represent their names,
    sort this dictionary giving priority to the provided signature.
    """
    params_name = list(params.keys())
    priority_params = []
    for p in signature:
        if p in params_name:
            priority_params.append((p, params[p]))
    # sort alphabetically the remaining parameters
    secondary_params = [
        (k,  v) for k, v in params.items() if k not in signature]
    secondary_params = sorted(
        secondary_params, key=lambda item: item[0])
    return dict(priority_params + secondary_params)


def _get_parameters_dict(displayed_params: list) -> dict:
    """
    Parameters
    ==========
    displayed_params : list
        A list with the form [
            ("param_name_1", parameter_1),
            ("param_name_2", parameter_2),
        ]

    Returns
    =======
    A dictionary with the form {
        "param_name_1": {
            "type": "something",
            "doc": "docstring parameter 1"
        },
        "param_name_2": {
            "type": "something",
            "doc": "docstring parameter 2"
        }
    }
    """
    parameters = {}
    for name, p in displayed_params:
        if type(p) in _PARAM_TYPE_MAP:
            type_ = _PARAM_TYPE_MAP[type(p)]
        elif isinstance(p, param.Dict):
            # this is necessary in order to catch _ParametersDict, defined
            # in series/base.py, which is an instance of param.Dict. If this
            # if statement was not present, it would go into the next one,
            # causing errors.
            type_ = "dict"
        elif isinstance(p, param.ClassSelector):
            classes = p.class_
            if (
                hasattr(classes, "__name__")
                and (classes.__name__ in ["ndarray", "Tuple"])
            ):
                classes = [classes]
            elif not hasattr(classes, "__iter__"):
                classes = [classes]
            type_ = ", ".join([str(t.__name__) for t in classes])
        elif isinstance(p, param.Selector):
            available_options = list(p.objects.values())
            types = sorted(set([type(t).__name__ for t in available_options]))
            type_ = ", ". join(types)
        elif type(p).__name__ == "_CastToInteger":
            type_ = "int"
        else:
            type_ = ""

        unindented = textwrap.dedent("< No docstring available >" if p.doc is None else p.doc)

        try:
            if isinstance(p, param.Selector):
                unindented += "\nPossible options: "
                wrapped_val = lambda t: f"'{t}'" if isinstance(t, str) else str(t)
                z = lambda: zip(p.objects.keys(), p.objects.values())
                if all((k == v) or (k == str(v)) for k, v in z()):
                    unindented += f"{list(p.objects.values())}"
                else:
                    unindented += "\n"
                    for k, v in z():
                        unindented += f"\n* {wrapped_val(v)}: {k}"
                    unindented += "\n"
                unindented += f"\nDefault value: {wrapped_val(p.default)}."
            elif isinstance(p, (param.Integer, param.Number)):
                if p.bounds is not None:
                    lb = str(p.bounds[0]) if p.bounds[0] is not None else "-∞"
                    ub = str(p.bounds[1]) if p.bounds[1] is not None else "∞"
                    fs = "≤" if p.inclusive_bounds[0] else "<"
                    fs = fs if lb != "-∞" else "<"
                    ss = "≤" if p.inclusive_bounds[1] else "<"
                    ss = ss if ub != "∞" else "<"
                    unindented += f"\nIt must be: {lb} {fs} {name} {ss} {ub}. "
                unindented += f"\nDefault value: {p.default}."
            elif isinstance(p, param.Boolean):
                unindented += f"\nDefault value: {p.default}."
        except Exception as err:
            print(f"Error processing parameter '{name}':", err)

        if (WARN_MISFORMATTED_DOCSTRINGS
            and not unindented.startswith("\n")  and len(unindented.splitlines()) > 1):
            param.main.warning("Multi-line docstring for %r is incorrectly formatted "
                                " (should start with newline)", name)
        # Strip any starting newlines
        while unindented.startswith("\n"):
            unindented = unindented[1:]

        parameters[name] = {
            "type": type_,
            "doc": unindented
        }

    return parameters


def split_docstring(docstring: str) -> dict:
    """
    Split the docstring of a function or class into sections, like
    Parameters, Returns, etc.

    Returns
    =======
    d : dict
        A dictionary having the form {
        "general": docstring_before_sections,
        "Parameter": docstring_for_parameters,
        "Returns": docstring_for_returns,
    }
    """
    docstring = textwrap.dedent(docstring).strip()

    # Regular expression to find section headers
    section_header_re = re.compile(r'^(?P<header>\w[\w ]*)\n[-=]{3,}$', re.MULTILINE)

    sections = {}
    last_index = 0
    current_section = "general"
    matches = list(section_header_re.finditer(docstring))

    if matches:
        # Process the general part (before first section)
        first_match = matches[0]
        general_text = docstring[:first_match.start()].strip()
        sections[current_section] = general_text if general_text else ""

        # Process each section
        for i, match in enumerate(matches):
            header = match.group("header").strip()
            start = match.end()
            end = matches[i + 1].start() if i + 1 < len(matches) else len(docstring)
            content = docstring[start:end].strip()
            sections[header] = content
    else:
        # No sections found, everything is general
        sections[current_section] = docstring

    return sections


def get_public_methods(cls) -> list:
    "Return a list of public methods of the provided class."
    attributes = [
        t for t in dir(cls) if (
            (t[0] != "_")
            and (not isinstance(getattr(cls, t), property))
            and callable(getattr(cls, t))
        )
    ]
    if issubclass(cls, param.Parameterized):
        attributes = [t for t in attributes if t not in cls.param]
    return attributes


def add_docstring_methods(docstring_sections: dict, cls):
    methods = get_public_methods(cls)
    all_docstrings = []

    for i, method in enumerate(methods):
        signature = inspect.signature(getattr(cls, method))
        str_signature = f"{signature}"
        str_signature = method + str_signature.replace(
            "self" if len(signature.parameters) == 1 else "self, ",
            "")

        docstring = getattr(cls, method).__doc__
        lines = [str_signature]
        if docstring is not None:
            sections = split_docstring(docstring)
            docstring = textwrap.dedent(sections["general"])
            lines.extend(
                textwrap.indent(docstring, "\t\t").split("\n"))

        if i % 2:  # Alternate red and blue for docstrings
            all_docstrings.extend([red % el for el in lines])
        else:
            all_docstrings.extend([blue % el for el in lines])

    if len(all_docstrings) > 0:
        docstring_sections["Methods"] = "\n" + "\n".join(all_docstrings)
    return docstring_sections


def extract_parameters_from_docstring(doc: str) -> dict:
    """
    Given a docstring section, for example the content of `Parameters`,
    returns a dictionary mapping parameters name and type (if any) to its
    docstring.

    Parameters
    ==========
    doc : str
        Multiline docstring section, for example the content of the
        `Parameters` section.

    Returns
    =======
    A dictionary with the form {
        "param_name_1": {
            "type": "something",
            "doc": "docstring parameter 1"
        },
        "param_name_2": {
            "type": "something",
            "doc": "docstring parameter 2"
        }
    }
    """
    if not doc:
        return {}

    # remove leading whitespaces so that lines starting with any non-whitespace
    # characters should be lines containing the parameters name and type.
    doc = textwrap.dedent(doc)

    lines = doc.splitlines()
    params = {}
    current_key = None
    key_types = None
    current_desc = []

    for line in lines:
        # Match lines like these:
        # a : int
        # b :
        # c : bool, dict
        # d, e : float
        match = None
        if (len(line) > 0) and (line[0] != " "):
            # The idea is that the match should happens on lines that do not
            # start with an empty character. This prevent elements like
            # this one from being matched, because documentation lines usually
            # starts with empty characters:
            # :py:class:`ipywidgets.widgets.widget_float.FloatSlider`
            match = param_pattern.match(line)
        if match:
            if current_key:
                params[current_key] = {
                    "type": key_types,
                    "doc": strip_indent(current_desc)
                }
            current_key = match.group(1)
            key_types = match.group(2)
            current_desc = []
        elif current_key:
            current_desc.append(line)

    if current_key:
        params[current_key] = {
            "type": key_types,
            "doc": strip_indent(current_desc)
        }

    return params


def strip_indent(lines):
    """Remove common leading whitespace from all lines."""
    return textwrap.dedent("\n".join(lines)).rstrip()


def modify_graphics_doc(series, replace={}, exclude=[], style="numpydoc"):
    """
    This decorator take a function from spb.graphics module and modify
    the docstring like so:

    1. Takes the existing docstring.
    2. Split it into different sections, like 'Parameters', 'Examples', etc.
    3. Take the 'series' and extract its parameters.
    5. Merge all parameters.
    6. Reconstruct the docstring, including all parameters.
    """
    def decorator(func):
        original_docstring = func.__doc__
        if original_docstring is None:
            return func

        # split the original docstring into sections
        docstring_sections = split_docstring(original_docstring)
        exclude.append("evaluator")

        # rearrange the sections and add colors
        final_docstring = ""
        for title in numpydoc_sections_to_look_for:
            if title != "Parameters":
                if title in docstring_sections:
                    if title == "general":
                        final_docstring += f"\n{docstring_sections[title]}"
                    else:
                        header = f"\n\n{green % title}"
                        header += green % f"\n{'=' * len(title)}\n"
                        final_docstring += header + docstring_sections[title]
            else:
                params_dict_from_docstring = {}
                if "Parameters" in docstring_sections:
                    params_dict_from_docstring = extract_parameters_from_docstring(
                        docstring_sections["Parameters"])

                # extract series parameters
                params, _, _ = _get_param_info_helper(
                    series, include_super=True)
                displayed_params = list(params.items())
                params_dict_from_series = _get_parameters_dict(
                    displayed_params)

                # combine all parameters
                dict_with_all_params = params_dict_from_series.copy()
                dict_with_all_params.update(params_dict_from_docstring)

                # replace existing param docstring with
                # user-provided ones
                for _, param_docstring in replace.items():
                    param_dict = extract_parameters_from_docstring(
                        param_docstring)
                    dict_with_all_params.update(param_dict)

                # remove any unwanted parameters
                for param_name in exclude:
                    dict_with_all_params.pop(param_name, None)

                # sort the parameters according to the function signature
                signature = inspect.signature(func)
                signature = list(signature.parameters.keys())
                signature = [
                    p for p in signature if p not in ["self", "kwargs"]]
                dict_with_all_params = _sort_parameters_by_signature(
                    dict_with_all_params, signature)

                # put together all parameters
                contents = _assemble_parameters_docstring(
                    dict_with_all_params, style)

                header = f"\n\n{green % title}"
                header += green % f"\n{'=' * len(title)}\n"
                final_docstring += header + contents

        func.__doc__ = final_docstring
        return func
    return decorator


def modify_plot_functions_doc(
    series, replace={}, exclude=[], priority=[], style="numpydoc"
):
    """
    This decorator take a function from spb.plot_functions module and modify
    the docstring like so:

    1. Takes the existing docstring.
    2. Split it into different sections, like 'Parameters', 'Examples', etc.
    3. Take the 'series' and extract its parameters.
    4. Take the 'PlotAttributes' and extract its parameters.
    5. Merge all parameters.
    6. Reconstruct the docstring, including all parameters.
    """
    from spb.backends.base_backend import PlotAttributes

    def decorator(func):
        # split the original docstring into sections
        original_docstring = func.__doc__
        docstring_sections = split_docstring(original_docstring)
        exclude.append("evaluator")

        final_docstring = ""
        for title in numpydoc_sections_to_look_for:
            if title != "Parameters":
                if title in docstring_sections:
                    if title == "general":
                        final_docstring += f"\n{docstring_sections[title]}"
                    else:
                        header = f"\n\n{green % title}"
                        header += green % f"\n{'=' * len(title)}\n"
                        final_docstring += header + docstring_sections[title]
            else:
                # extract any paramater documented in the func docstring
                params_dict_from_docstring = {}
                if "Parameters" in docstring_sections:
                    params_dict_from_docstring = extract_parameters_from_docstring(
                        docstring_sections["Parameters"])

                # extract parameters from the series
                series_docstring = series.__doc__
                if series_docstring is None:
                    series_docstring = ""
                for col in colors:
                    # remove any color inserted by the pager.
                    # if not done, the `split_docstring` command would
                    # not work.
                    first, second = col.split("%s")
                    series_docstring = series_docstring.replace(
                        first, "").replace(second, "")
                series_docstring_sections = split_docstring(series_docstring)
                params_dict_from_series = {}
                if "Parameters" in series_docstring_sections:
                    params_dict_from_series = extract_parameters_from_docstring(
                        series_docstring_sections["Parameters"])

                # add `graphics` parameters
                params_graphics, _, _ = _get_param_info_helper(
                        PlotAttributes, include_super=True)
                displayed_params = list(params_graphics.items())
                params_dict_from_graphics = _get_parameters_dict(
                    displayed_params)

                dict_with_all_params = params_dict_from_series.copy()
                dict_with_all_params.update(params_dict_from_graphics)
                dict_with_all_params.update(params_dict_from_docstring)

                # replace existing param docstring with
                # user-provided ones
                for _, param_docstring in replace.items():
                    param_dict = extract_parameters_from_docstring(
                        param_docstring)
                    dict_with_all_params.update(param_dict)

                # remove any unwanted parameters
                for param_name in exclude:
                    dict_with_all_params.pop(param_name, None)

                # sort params accordingly to the series.__init__ method
                init_signature = list(
                    inspect.signature(series.__init__).parameters.keys())
                init_signature = [
                    p for p in init_signature if p not in ["self", "kwargs"]]
                init_signature = priority + init_signature
                dict_with_all_params = _sort_parameters_by_signature(
                    dict_with_all_params, init_signature)

                contents = _assemble_parameters_docstring(
                    dict_with_all_params, style)

                header = f"\n\n{green % title}"
                header += green % f"\n{'=' * len(title)}\n"
                final_docstring += header + contents

        func.__doc__ = final_docstring
        return func
    return decorator


def modify_parameterized_doc(style="numpydoc"):
    """
    This decorator take a subclass of param.Parameterized and modify the
    auto-generated docstring like so:

    1. remove the summary table listing all parameters, their default
       values, if they are read/write, etc.
    2. loop over its parameters and sort them alphabetically, but first
       lists the mandatory parameters defined in the __init__ signature.
       Selectors will show all the available options. Selectors, numbers,
       booleans will also show the default value.
    3. implement two styles:

       * 'param': default from the param module.
       * 'numpydoc': what I'd like to be shown.
    """
    def decorator(cls):
        param_pager = MyParamPager(metaclass=True, style=style)

        current_docstring = cls.__doc__
        if current_docstring is None:
            return cls

        # remove param's autogenerated documentation sections in order
        # to recover the original documentation written by the dev
        current_docstring = current_docstring.split("\n")
        search_for = [red, blue, green, cyan, "Parameters of"]
        for i, line in enumerate(current_docstring):
            if any(t in line for t in search_for):
                break

        try:
            original_docstring = "\n".join(current_docstring[:i])
            # split the original docstring into sections
            docstring_sections = split_docstring(original_docstring)

            if not issubclass(cls, param.ParameterizedFunction):
                # add a section for the public methods
                docstring_sections = add_docstring_methods(docstring_sections, cls)

            # rearrange the sections and add colors to the titles
            final_docstring = ""
            for title in numpydoc_sections_to_look_for:
                if title != "Parameters":
                    if title in docstring_sections:
                        if title == "general":
                            final_docstring += f"\n{docstring_sections[title]}"
                        else:
                            header = f"\n\n{green % title}"
                            header += green % f"\n{'=' * len(title)}\n"
                            final_docstring += header + docstring_sections[title]
                else:
                    final_docstring += f"\n{param_pager(cls)}"

            cls.__doc__ = final_docstring
        except Exception as err:
            print(f"{type(err).__name__}: {err}")

        return cls

    return decorator
