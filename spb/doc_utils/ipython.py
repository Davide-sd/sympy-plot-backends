import inspect
import param
from param.ipython import ParamPager
import re
import textwrap

# ANSI color codes for the IPython pager
red   = '\x1b[1;31m%s\x1b[0m'
blue  = '\x1b[1;34m%s\x1b[0m'
green = '\x1b[1;32m%s\x1b[0m'
cyan = '\x1b[1;36m%s\x1b[0m'
WARN_MISFORMATTED_DOCSTRINGS = False


def _validate_style(style: str):
    available_styles = ["param", "numpydoc"]
    if style not in available_styles:
        raise ValueError(
            f"`style` must be one of these options: {available_styles}."
            f" Instead, '{style}' was received."
        )


class MyParamPager(ParamPager):
    def __init__(self, metaclass=False, style="param"):
        super().__init__(metaclass)
        _validate_style(style)
        self.style = style

    def __call__(self, param_obj):
        """
        Given a Parameterized object or class, display information
        about the parameters in the IPython pager.
        """

        title = None
        if not self.metaclass:
            parameterized_object = isinstance(param_obj, param.Parameterized)
            parameterized_class = (isinstance(param_obj,type)
                                   and  issubclass(param_obj,param.Parameterized))

            if not (parameterized_object or parameterized_class):
                print("Object is not a Parameterized class or object.")
                return

            if parameterized_object:
                # Only show the name if not autogenerated
                class_name = param_obj.__class__.__name__
                default_name = re.match('^'+class_name+'[0-9]+$', param_obj.name)
                obj_name = '' if default_name else (' %r' % param_obj.name)
                title = f'Parameters of {class_name!r} instance{obj_name}'

        if title is None:
            title = 'Parameters of %r' % param_obj.name

        heading_line = '=' * len(title)
        heading_text = f"{title}\n{heading_line}\n"

        param_info = self.get_param_info(param_obj, include_super=True)
        if not param_info[0]:
            top_heading = green % heading_text
            return f"{top_heading}\nObject has no parameters."

        heading_text = 'Parameters'
        heading_string = f"{heading_text}\n{'=' * len(heading_text)}"
        docstring_heading = (green % heading_string)
        # print("1")
        docstrings = self.param_docstrings(
            param_info, max_col_len=100, only_changed=False)
        # print("2")
        return f"\n\n{docstring_heading}\n\n{docstrings}"

    def param_docstrings(self, info, max_col_len=100, only_changed=False):
        """
        Build a string to that presents all of the parameter
        docstrings in a clean format (alternating red and blue for
        readability).
        """

        (params, val_dict, changed) = info
        contents = []
        displayed_params = []

        for name in self.sort_by_precedence(params):
            if only_changed and not (name in changed):
                continue
            displayed_params.append((name, params[name]))

        parameters_dict = _get_parameters_dict(displayed_params)
        contents = _assemble_parameters_docstring(
            parameters_dict, self.style)
        return contents

    def get_param_info(self, obj, include_super=True):
        """
        Get the parameter dictionary, the list of modifed parameters
        and the dictionary of parameter values. If include_super is
        True, parameters are also collected from the super classes.
        """
        params, val_dict, changed = _get_param_info_helper(obj, include_super)
        return (params, val_dict, changed)


def _assemble_parameters_docstring(parameters: dict, style: str) -> str:
    right_shift = max(len(name) for name in parameters) + 2
    contents = []

    for i, name in enumerate(parameters):
        if style == "param":
            heading = f"{name}: "
        else:
            heading = f"{name} : {parameters[name]["type"]}"

        unindented = parameters[name]["doc"]

        lines = unindented.splitlines()
        if style == "param":
            if len(lines) > 1:
                tail = [f"{' '  * right_shift}{line}" for line in lines[1:]]
                all_lines = [heading.ljust(right_shift) + lines[0]] + tail
            elif len(lines) == 1:
                all_lines = [heading.ljust(right_shift) + lines[0]]
            else:
                all_lines = []
        else:
            all_lines = [heading] + [
                textwrap.indent(line, "    ") for line in lines]

        if i % 2:  # Alternate red and blue for docstrings
            contents.extend([red % el for el in all_lines])
        else:
            contents.extend([blue % el for el in all_lines])
    return "\n".join(contents)

def _get_parameters_from_object(obj) -> dict:
    """
    Returns
    =======
    A dictionary with the form {
        "param_name_1": parameter_1,
        "param_name_2": parameter_2,
    }
    where parameter_1, parameter_2 are parameters from the `param` module.
    """
    if (
        (not isinstance(obj, param.Parameterized))
        and (not issubclass(obj, param.Parameterized))
    ):
        return {}

    params = dict(obj.param.objects('existing'))
    # do not show 'private' parameters
    params = {k: v for k, v in params.items() if k[0] != "_"}
    if hasattr(obj, "_exclude_params_from_doc"):
        params = {
            k: v for k, v in params.items()
            if k not in obj._exclude_params_from_doc
        }
    return params


def _get_param_info_helper(obj, include_super=True):
    """
    Get the parameter dictionary, the list of modifed parameters
    and the dictionary of parameter values. If include_super is
    True, parameters are also collected from the super classes.
    """

    params = _get_parameters_from_object(obj)

    # get the class' __init__ method's or __call__ method's signature
    method = obj.__init__
    if issubclass(obj, param.ParameterizedFunction):
        method = obj.__call__
    init_signature = list(inspect.signature(method).parameters.keys())
    init_signature = [
        p for p in init_signature if p not in ["self", "kwargs"]]

    # sort parameters: first the ones shown in the signature, then
    # alphabetically sort the remaining
    params = _sort_parameters_by_signature(params, init_signature)

    if isinstance(obj, type):
        changed = []
        val_dict = {k: p.default for (k, p) in params.items()}
        self_class = obj
    else:
        changed = list(obj.param.values(onlychanged=True).keys())
        val_dict = obj.param.values()
        self_class = obj.__class__

    if not include_super:
        params = {k:v for (k,v) in params.items()
                    if k in self_class.__dict__}

    params.pop('name') # Already displayed in the title.
    return (params, val_dict, changed)


def _sort_parameters_by_signature(params: dict, signature: list) -> dict:
    """
    Given a dictionary of parameters where the keys represent their names,
    sort this dictionary giving priority to the provided signature.
    """
    params_name = list(params.keys())
    priority_params = []
    for p in signature:
        if p in params_name:
            priority_params.append((p, params[p]))
    # sort alphabetically the remaining parameters
    secondary_params = [
        (k,  v) for k, v in params.items() if k not in signature]
    secondary_params = sorted(
        secondary_params, key=lambda item: item[0])
    return dict(priority_params + secondary_params)



def _get_parameters_dict(displayed_params: list) -> dict:
    """
    Parameters
    ==========
    displayed_params : dict
        A list with the form [
            ("param_name_1", parameter_1),
            ("param_name_2", parameter_2),
        ]

    Returns
    =======
    A dictionary with the form {
        "param_name_1": {
            "type": "something",
            "doc": "docstring parameter 1"
        },
        "param_name_2": {
            "type": "something",
            "doc": "docstring parameter 2"
        }
    }
    """
    parameters = {}
    for name, p in displayed_params:
        if type(p) in _PARAM_TYPE_MAP:
            type_ = _PARAM_TYPE_MAP[type(p)]
        elif isinstance(p, param.Dict):
            # this is necessary in order to catch _ParametersDict, defined
            # in series/base.py, which is an instance of param.Dict. If this
            # if statement was not present, it would go into the next one,
            # causing errors.
            type_ = "dict"
        elif isinstance(p, param.ClassSelector):
            classes = p.class_
            if not hasattr(classes, "__iter__"):
                classes = [classes]
            type_ = ", ".join([str(t) for t in classes])
        else:
            type_ = ""

        unindented = textwrap.dedent("< No docstring available >" if p.doc is None else p.doc)

        try:
            if isinstance(p, param.Selector):
                unindented += "\nPossible options: "
                wrapped_val = lambda t: f"'{t}'" if isinstance(t, str) else str(t)
                z = lambda: zip(p.objects.keys(), p.objects.values())
                if all((k == v) or (k == str(v)) for k, v in z()):
                    unindented += f"{list(p.objects.values())}"
                else:
                    unindented += "\n"
                    for k, v in z():
                        unindented += f"\n* {wrapped_val(v)}: {k}"
                    unindented += "\n"
                unindented += f"\nDefault value: {wrapped_val(p.default)}"
            elif isinstance(p, (param.Integer, param.Number)):
                if p.bounds is not None:
                    lb = str(p.bounds[0]) if p.bounds[0] is not None else "-∞"
                    ub = str(p.bounds[1]) if p.bounds[1] is not None else "∞"
                    fs = "≤" if p.inclusive_bounds[0] else "<"
                    fs = fs if lb != "-∞" else "<"
                    ss = "≤" if p.inclusive_bounds[1] else "<"
                    ss = ss if ub != "∞" else "<"
                    unindented += f"\nIt must be: {lb} {fs} {name} {ss} {ub}"
                unindented += f"\nDefault value: {p.default}"
        except Exception as err:
            print(f"Error processing parameter '{name}':", err)

        if (WARN_MISFORMATTED_DOCSTRINGS
            and not unindented.startswith("\n")  and len(unindented.splitlines()) > 1):
            param.main.warning("Multi-line docstring for %r is incorrectly formatted "
                                " (should start with newline)", name)
        # Strip any starting newlines
        while unindented.startswith("\n"):
            unindented = unindented[1:]

        parameters[name] = {
            "type": type_,
            "doc": unindented
        }

    return parameters


_PARAM_TYPE_MAP = {
    param.String: "str",
    param.Boolean: "bool",
    param.Integer: "int",
    param.Number: "float",
    param.Tuple: "tuple",
    param.List: "list",
    param.Dict: "dict",
    param.Callable: "callable",
    param.Parameter: "",
}


def split_docstring(docstring):
    docstring = textwrap.dedent(docstring).strip()

    # Regular expression to find section headers
    section_header_re = re.compile(r'^(?P<header>\w[\w ]*)\n[-=]{3,}$', re.MULTILINE)

    sections = {}
    last_index = 0
    current_section = "general"
    matches = list(section_header_re.finditer(docstring))

    if matches:
        # Process the general part (before first section)
        first_match = matches[0]
        general_text = docstring[:first_match.start()].strip()
        sections[current_section] = general_text if general_text else ""

        # Process each section
        for i, match in enumerate(matches):
            header = match.group("header").strip()
            start = match.end()
            end = matches[i + 1].start() if i + 1 < len(matches) else len(docstring)
            content = docstring[start:end].strip()
            sections[header] = content
    else:
        # No sections found, everything is general
        sections[current_section] = docstring

    return sections


def get_public_methods(cls):
    "Return a list of public methods of the provided class."
    attributes = [
        t for t in dir(cls) if (
            (t[0] != "_")
            and (not isinstance(getattr(cls, t), property))
            and callable(getattr(cls, t))
        )
    ]
    if issubclass(cls, param.Parameterized):
        attributes = [t for t in attributes if t not in cls.param]
    return attributes


def add_docstring_methods(docstring_sections, cls):
    methods = get_public_methods(cls)
    all_docstrings = []

    for i, method in enumerate(methods):
        signature = inspect.signature(getattr(cls, method))
        str_signature = f"{signature}"
        str_signature = method + str_signature.replace(
            "self" if len(signature.parameters) == 1 else "self, ",
            "")

        docstring = getattr(cls, method).__doc__
        lines = [str_signature]
        if docstring is not None:
            sections = split_docstring(docstring)
            docstring = textwrap.dedent(sections["general"])
            lines.extend(
                textwrap.indent(docstring, "\t\t").split("\n"))

        if i % 2:  # Alternate red and blue for docstrings
            all_docstrings.extend([red % el for el in lines])
        else:
            all_docstrings.extend([blue % el for el in lines])

    if len(all_docstrings) > 0:
        docstring_sections["Methods"] = "\n" + "\n".join(all_docstrings)
    return docstring_sections


def extract_parameters_from_docstring(doc: str) -> dict:
    """
    Given a docstring section, for example the content of `Parameters`,
    returns a dictionary mapping parameters name and type (if any) to its
    docstring.

    Parameters
    ==========
    doc : str
        Multiline docstring section, for example the content of the
        `Parameters` section.

    Returns
    =======
    A dictionary with the form {
        "param_name_1": {
            "type": "something",
            "doc": "docstring parameter 1"
        },
        "param_name_2": {
            "type": "something",
            "doc": "docstring parameter 2"
        }
    }
    """
    if not doc:
        return {}

    lines = doc.splitlines()
    params = {}
    current_key = None
    key_types = None
    current_desc = []

    for line in lines:
        # Match lines like: a : int, b :, c : bool, dict
        match = re.match(r"^\s*(\w+\s*:\s*.*)", line)
        if match:
            if current_key:
                params[current_key] = {
                    "type": key_types,
                    "doc": strip_indent(current_desc)
                }
            current_key = match.group(1).strip()
            current_key, key_types = [t.strip() for t in current_key.split(":")]
            current_desc = []
        elif current_key:
            current_desc.append(line)

    if current_key:
        params[current_key] = {
            "type": key_types,
            "doc": strip_indent(current_desc)
        }

    return params


def strip_indent(lines):
    """Remove common leading whitespace from all lines."""
    return textwrap.dedent("\n".join(lines)).rstrip()


def extract_params_from_cls(cls):
    if not issubclass(cls, param.Parameterized):
        return {}

    # for


def generate_doc_for_ordinary_functions(func_map, style="numpydoc"):
    _validate_style(style)
    try:
        get_ipython()
        # param_pager = MyParamPager(metaclass=True, style="numpydoc")

        for func, objs in func_map.items():
            original_docstring = func.__doc__

            try:
                # split the original docstring into sections
                docstring_sections = split_docstring(original_docstring)
                # print("len(docstring_sections)", len(docstring_sections))

                # rearrange the sections and add colors to the titles
                numpydoc_sections_to_look_for = [
                    "general", "Parameters", "Attributes", "Methods",
                    "Returns", "Yields", "Raises", "Warns", "Warnings",
                    "Examples", "Notes", "References", "See Also",
                ]
                final_docstring = ""
                for title in numpydoc_sections_to_look_for:
                    # print("title", title, docstring_sections[title])

                    if title != "Parameters":
                        if title in docstring_sections:
                            if title == "general":
                                final_docstring += f"\n{docstring_sections[title]}"
                            else:
                                header = f"\n\n{green % title}"
                                header += green % f"\n{'=' * len(title)}\n"
                                final_docstring += header + docstring_sections[title]
                    else:
                        params_dict_from_docstring = {}
                        if "Parameters" in docstring_sections:
                            params_dict_from_docstring = extract_parameters_from_docstring(
                                docstring_sections["Parameters"])

                        params = {}
                        for obj in objs:
                            current_params, _, _ = _get_param_info_helper(
                                obj, include_super=True)
                            params.update(current_params)

                        displayed_params = list(params.items())
                        params_dict_from_obj = _get_parameters_dict(
                            displayed_params)

                        dict_with_all_params = params_dict_from_obj.copy()
                        dict_with_all_params.update(params_dict_from_docstring)

                        signature = inspect.signature(func)
                        signature = list(signature.parameters.keys())
                        signature = [
                            p for p in signature if p not in ["self", "kwargs"]]
                        dict_with_all_params = _sort_parameters_by_signature(
                            dict_with_all_params, signature)

                        # print("wtf")
                        # print(dict_with_all_params)
                        contents = _assemble_parameters_docstring(
                            dict_with_all_params, style)

                        header = f"\n\n{green % title}"
                        header += green % f"\n{'=' * len(title)}\n"
                        final_docstring += header + contents

                func.__doc__ = final_docstring
            except Exception as err:
                print(f"{type(err).__name__}: {err}")

    except:
        pass


def generate_doc(*classes):
    try:
        get_ipython()
        param_pager = MyParamPager(metaclass=True)

        for cls in classes:
            current_docstring = cls.__doc__
            # remove param's autogenerated documentation sections in order
            # to recover the original documentation written by the dev
            current_docstring = current_docstring.split("\n")
            search_for = [red, blue, green, cyan, "Parameters of"]
            for i, line in enumerate(current_docstring):
                if any(t in line for t in search_for):
                    break
            try:
                original_docstring = "\n".join(current_docstring[:i])
                # split the original docstring into sections
                docstring_sections = split_docstring(original_docstring)

                if not issubclass(cls, param.ParameterizedFunction):
                    # add a section for the public methods
                    docstring_sections = add_docstring_methods(docstring_sections, cls)

                # I would also like to include a signature of the __init__ method
                init_signature = f"Init signature:\n{cls.__name__}{inspect.signature(cls.__init__)}"
                init_signature = init_signature.replace("self, ", "")
                # rearrange the sections and add colors to the titles
                numpydoc_sections_to_look_for = [
                    "general", "Parameters", "Attributes", "Methods",
                    "Returns", "Yields", "Raises", "Warns", "Warnings",
                    "Examples", "Notes", "References", "See Also",
                ]
                final_docstring = ""
                # print("a")
                for title in numpydoc_sections_to_look_for:
                    if title != "Parameters":
                        if title in docstring_sections:
                            if title == "general":
                                final_docstring += f"\n{docstring_sections[title]}"
                                # final_docstring += f"\n\n{init_signature}"
                            else:
                                header = f"\n\n{green % title}"
                                header += green % f"\n{'=' * len(title)}\n"
                                final_docstring += header + docstring_sections[title]
                    else:
                        final_docstring += f"\n{param_pager(cls)}"
                # print("b")
                cls.__doc__ = final_docstring
                # print(final_docstring)
            except Exception as err:
                print(f"{type(err).__name__}: {err}")

    except:
        pass