import inspect
import param
from param.ipython import ParamPager
import re
import textwrap

# ANSI color codes for the IPython pager
red   = '\x1b[1;31m%s\x1b[0m'
blue  = '\x1b[1;34m%s\x1b[0m'
green = '\x1b[1;32m%s\x1b[0m'
cyan = '\x1b[1;36m%s\x1b[0m'
WARN_MISFORMATTED_DOCSTRINGS = False


class MyParamPager(ParamPager):
    def __call__(self, param_obj):
        """
        Given a Parameterized object or class, display information
        about the parameters in the IPython pager.
        """

        title = None
        if not self.metaclass:
            parameterized_object = isinstance(param_obj, param.Parameterized)
            parameterized_class = (isinstance(param_obj,type)
                                   and  issubclass(param_obj,param.Parameterized))

            if not (parameterized_object or parameterized_class):
                print("Object is not a Parameterized class or object.")
                return

            if parameterized_object:
                # Only show the name if not autogenerated
                class_name = param_obj.__class__.__name__
                default_name = re.match('^'+class_name+'[0-9]+$', param_obj.name)
                obj_name = '' if default_name else (' %r' % param_obj.name)
                title = f'Parameters of {class_name!r} instance{obj_name}'

        if title is None:
            title = 'Parameters of %r' % param_obj.name

        heading_line = '=' * len(title)
        heading_text = f"{title}\n{heading_line}\n"

        param_info = self.get_param_info(param_obj, include_super=True)
        if not param_info[0]:
            top_heading = green % heading_text
            return f"{top_heading}\nObject has no parameters."

        heading_text = 'Parameters'
        heading_string = f"{heading_text}\n{'=' * len(heading_text)}"
        docstring_heading = (green % heading_string)
        docstrings = self.param_docstrings(
            param_info, max_col_len=100, only_changed=False)
        return f"\n\n{docstring_heading}\n\n{docstrings}"

    def param_docstrings(self, info, max_col_len=100, only_changed=False):
        """
        Build a string to that presents all of the parameter
        docstrings in a clean format (alternating red and blue for
        readability).
        """

        (params, val_dict, changed) = info
        contents = []
        displayed_params = []

        for name in self.sort_by_precedence(params):
            if only_changed and not (name in changed):
                continue
            displayed_params.append((name, params[name]))

        right_shift = max(len(name) for name, _ in displayed_params)+2

        for i, (name, p) in enumerate(displayed_params):
            heading = "%s: " % name
            unindented = textwrap.dedent("< No docstring available >" if p.doc is None else p.doc)

            try:
                if isinstance(p, param.Selector):
                    unindented += "\nPossible options: "
                    wrapped_val = lambda t: f"'{t}'" if isinstance(t, str) else str(t)
                    z = lambda: zip(p.objects.keys(), p.objects.values())
                    if all((k == v) or (k == str(v)) for k, v in z()):
                        unindented += f"{list(p.objects.values())}"
                    else:
                        unindented += "\n"
                        for k, v in z():
                            unindented += f"\n* {wrapped_val(v)}: {k}"
                        unindented += "\n"
                    unindented += f"\nDefault value: {wrapped_val(p.default)}"
                elif isinstance(p, (param.Integer, param.Number)):
                    if p.bounds is not None:
                        lb = str(p.bounds[0]) if p.bounds[0] is not None else "-∞"
                        ub = str(p.bounds[1]) if p.bounds[1] is not None else "∞"
                        fs = "≤" if p.inclusive_bounds[0] else "<"
                        fs = fs if lb != "-∞" else "<"
                        ss = "≤" if p.inclusive_bounds[1] else "<"
                        ss = ss if ub != "∞" else "<"
                        unindented += f"\nIt must be: {lb} {fs} {name} {ss} {ub}"
                    unindented += f"\nDefault value: {p.default}"
            except Exception as err:
                print(f"Error processing parameter '{name}':", err)

            if (WARN_MISFORMATTED_DOCSTRINGS
                and not unindented.startswith("\n")  and len(unindented.splitlines()) > 1):
                param.main.warning("Multi-line docstring for %r is incorrectly formatted "
                                   " (should start with newline)", name)
            # Strip any starting newlines
            while unindented.startswith("\n"):
                unindented = unindented[1:]

            lines = unindented.splitlines()
            if len(lines) > 1:
                tail = [f"{' '  * right_shift}{line}" for line in lines[1:]]
                all_lines = [ heading.ljust(right_shift) + lines[0]] + tail
            elif len(lines) == 1:
                all_lines = [ heading.ljust(right_shift) + lines[0]]
            else:
                all_lines = []

            if i % 2:  # Alternate red and blue for docstrings
                contents.extend([red %el for el in all_lines])
            else:
                contents.extend([blue %el for el in all_lines])

        return "\n".join(contents)

    def get_param_info(self, obj, include_super=True):
        """
        Get the parameter dictionary, the list of modifed parameters
        and the dictionary of parameter values. If include_super is
        True, parameters are also collected from the super classes.
        """

        params = dict(obj.param.objects('existing'))
        # do not show 'private' parameters
        params = {k: v for k, v in params.items() if k[0] != "_"}
        if hasattr(obj, "_exclude_params_from_doc"):
            params = {
                k: v for k, v in params.items()
                if k not in obj._exclude_params_from_doc
            }
        # get the class' __init__ method's signature
        init_signature = list(inspect.signature(obj.__init__).parameters.keys())
        init_signature = [
            p for p in init_signature if p not in ["self", "kwargs"]]
        # sort parameters: first the ones shown in the signature, then
        # alphabetically sort the remaining
        params = dict(sorted(params.items()))
        params_name = list(params.keys())
        priority_params = []
        for p in init_signature:
            if p in params_name:
                priority_params.append((p, params[p]))
        secondary_params = [
            (k,  v) for k, v in params.items() if k not in init_signature]
        params = dict(priority_params + secondary_params)

        if isinstance(obj,type):
            changed = []
            val_dict = {k:p.default for (k,p) in params.items()}
            self_class = obj
        else:
            changed = list(obj.param.values(onlychanged=True).keys())
            val_dict = obj.param.values()
            self_class = obj.__class__

        if not include_super:
            params = {k:v for (k,v) in params.items()
                      if k in self_class.__dict__}

        params.pop('name') # Already displayed in the title.
        return (params, val_dict, changed)


def split_docstring(docstring):
    docstring = textwrap.dedent(docstring).strip()

    # Regular expression to find section headers
    section_header_re = re.compile(r'^(?P<header>\w[\w ]*)\n[-=]{3,}$', re.MULTILINE)

    sections = {}
    last_index = 0
    current_section = "general"
    matches = list(section_header_re.finditer(docstring))

    if matches:
        # Process the general part (before first section)
        first_match = matches[0]
        general_text = docstring[:first_match.start()].strip()
        sections[current_section] = general_text if general_text else ""

        # Process each section
        for i, match in enumerate(matches):
            header = match.group("header").strip()
            start = match.end()
            end = matches[i + 1].start() if i + 1 < len(matches) else len(docstring)
            content = docstring[start:end].strip()
            sections[header] = content
    else:
        # No sections found, everything is general
        sections[current_section] = docstring

    return sections


def get_public_methods(cls):
    "Return a list of public methods of the provided class."
    attributes = [
        t for t in dir(cls) if (
            (t[0] != "_")
            and (not isinstance(getattr(cls, t), property))
            and callable(getattr(cls, t))
        )
    ]
    if issubclass(cls, param.Parameterized):
        attributes = [t for t in attributes if t not in cls.param]
    return attributes


def add_docstring_methods(docstring_sections, cls):
    methods = get_public_methods(cls)
    all_docstrings = []

    for i, method in enumerate(methods):
        signature = inspect.signature(getattr(cls, method))
        str_signature = f"{signature}"
        str_signature = method + str_signature.replace(
            "self" if len(signature.parameters) == 1 else "self, ",
            "")

        docstring = getattr(cls, method).__doc__
        lines = [str_signature]
        if docstring is not None:
            sections = split_docstring(docstring)
            docstring = textwrap.dedent(sections["general"])
            lines.extend(
                textwrap.indent(docstring, "\t\t").split("\n"))

        if i % 2:  # Alternate red and blue for docstrings
            all_docstrings.extend([red % el for el in lines])
        else:
            all_docstrings.extend([blue % el for el in lines])

    if len(all_docstrings) > 0:
        docstring_sections["Methods"] = "\n" + "\n".join(all_docstrings)
    return docstring_sections


def generate_doc(*classes):
    try:
        get_ipython()
        param_pager = MyParamPager(metaclass=True)

        for cls in classes:
            current_docstring = cls.__doc__
            # remove param's autogenerated documentation sections in order
            # to recover the original documentation written by the dev
            current_docstring = current_docstring.split("\n")
            search_for = [red, blue, green, cyan, "Parameters of"]
            for i, line in enumerate(current_docstring):
                if any(t in line for t in search_for):
                    break
            try:
                original_docstring = "\n".join(current_docstring[:i])
                # split the original docstring into sections
                docstring_sections = split_docstring(original_docstring)
                # add a section for the public methods
                docstring_sections = add_docstring_methods(docstring_sections, cls)
                # I would also like to include a signature of the __init__ method
                init_signature = f"Init signature:\n{cls.__name__}{inspect.signature(cls.__init__)}"
                init_signature = init_signature.replace("self, ", "")
                # rearrange the sections and add colors to the titles
                numpydoc_sections_to_look_for = [
                    "general", "Parameters", "Attributes", "Methods",
                    "Returns", "Yields", "Raises", "Warns", "Warnings",
                    "Examples", "Notes", "References", "See Also",
                ]
                final_docstring = ""
                for title in numpydoc_sections_to_look_for:
                    if title != "Parameters":
                        if title in docstring_sections:
                            if title == "general":
                                final_docstring += f"\n{docstring_sections[title]}"
                                # final_docstring += f"\n\n{init_signature}"
                            else:
                                header = f"\n\n{green % title}"
                                header += green % f"\n{'=' * len(title)}\n"
                                final_docstring += header + docstring_sections[title]
                    else:
                        final_docstring += f"\n{param_pager(cls)}"

                cls.__doc__ = final_docstring
                # print(final_docstring)
            except Exception as err:
                print(f"{type(err).__name__}: {err}")

    except:
        pass